<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Akash Selvadoss N - Portfolio</title>
  <style>
    /* --- Base & Typography --- */
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow-x: hidden;
    }
    html {
      scroll-behavior: smooth;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0d0d0d;
      color: #e0e0e0; /* Slightly softer white for text */
      cursor: none; /* Hide default cursor */
    }
    h1, h2, strong {
      color: #fff;
    }
    h2 {
      color: #ffcc70;
      margin-bottom: 25px; /* More space below headings */
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-size: 1.6rem;
    }
    p {
      line-height: 1.7; /* Improved readability for paragraphs */
      margin-bottom: 10px;
    }

    /* --- Vanta.js Background Container --- */
    #vanta-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
    }
    
    /* --- Splash Cursor Canvas --- */
    #splash-cursor-container {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 50;
        pointer-events: none;
        width: 100%;
        height: 100%;
    }
    #fluid-canvas {
        width: 100vw;
        height: 100vh;
        display: block;
    }


    /* --- Navigation Bar --- */
    nav {
      position: sticky;
      top: 0;
      width: 100%;
      padding: 15px 5%;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(13, 13, 13, 0.7);
      backdrop-filter: blur(10px);
      z-index: 100;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    nav a {
      color: #e0e0e0;
      text-decoration: none;
      margin: 0 20px;
      font-weight: 500;
      transition: color 0.3s ease, transform 0.3s ease;
    }
    nav a:hover, nav a.active {
      color: #ffcc70;
      transform: translateY(-2px);
    }

    /* --- Social Bar --- */
    .social-bar {
      position: fixed;
      top: 50%; /* Centered vertically */
      right: 20px;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column; /* Stacked vertically */
      gap: 15px;
      z-index: 10;
    }
    .social-bar a img {
      width: 28px; height: 28px;
      filter: drop-shadow(0 0 5px rgba(255,255,255,0.6));
      transition: transform 0.3s, filter 0.3s;
    }
    .social-bar a:hover img {
      transform: scale(1.2);
      filter: drop-shadow(0 0 8px #ffcc70);
    }

    /* --- Header --- */
    header {
      height: 100vh; /* Full screen height */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 0 20px;
      position: relative; /* Ensure content stays above Vanta background */
      z-index: 1;
    }
    header h1 {
      font-size: clamp(2.5rem, 8vw, 4.5rem); /* Responsive font size */
      background: linear-gradient(90deg, #fff, #ffcc70, #ff6ec7, #32e0c4);
      background-size: 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: glitter 8s linear infinite;
    }
    @keyframes glitter {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    header a.btn {
      margin-top: 30px;
      display: inline-block;
      padding: 14px 28px;
      border-radius: 50px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      text-decoration: none;
      font-weight: 500;
      transition: all 0.3s ease;
    }
    header a.btn:hover {
      background: rgba(255,204,112,0.8);
      color: #0d0d0d;
      border-color: #ffcc70;
      transform: scale(1.05) translateY(-3px);
      box-shadow: 0 8px 20px rgba(255, 204, 112, 0.3);
    }

    /* --- Sections (IMPROVED LAYOUT) --- */
    main {
      padding: 0 20px; /* Add padding for smaller screens */
      position: relative; /* Ensure content stays above Vanta background */
      z-index: 1;
    }
    section {
      max-width: 900px;
      margin: 100px auto; /* Increased vertical margin for spacing */
      padding: 40px; /* Increased padding */
      border-radius: 15px;
      background: rgba(20, 20, 20, 0.6);
      backdrop-filter: blur(12px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
     section:hover {
        box-shadow: 0 15px 40px rgba(0,0,0,0.7);
        transform: translateY(-5px);
    }

    /* --- About Me Section with Profile Picture (NEW) --- */
    .about-container {
        display: flex;
        align-items: center;
        gap: 40px; /* Space between image and text */
    }
    .profile-picture-container {
        flex-shrink: 0;
    }
    .profile-picture {
        width: 180px;
        height: 180px;
        border-radius: 50%; /* Perfect circle */
        object-fit: cover; /* Prevents image stretching */
        border: 4px solid #ffcc70;
        box-shadow: 0 0 20px rgba(255, 204, 112, 0.4);
    }
    .about-text {
        flex-grow: 1;
    }


    /* --- Custom List Styling --- */
    #skills ul, #certifications ul {
        list-style: none;
        padding-left: 10px;
    }
    #skills ul li, #certifications ul li {
        position: relative;
        padding-left: 30px;
        margin-bottom: 15px; /* Space out list items */
        font-size: 1.05rem;
    }
    #skills ul li::before, #certifications ul li::before {
        content: '▹'; /* Custom bullet point */
        position: absolute;
        left: 0;
        top: 0;
        color: #ffcc70;
        font-weight: bold;
    }

    /* --- Project Grid --- */
    .project-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 30px;
    }
    .project-card {
      background: rgba(255,255,255,0.05);
      border-radius: 10px;
      padding: 25px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .project-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.6);
    }
    .project-card strong {
      font-size: 1.3em;
      margin-bottom: 15px;
      color: #ffcc70;
    }
    .project-links-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 20px;
    }
    .project-link {
      display: inline-flex; /* Use flex to align icon and text */
      align-items: center;
      gap: 8px; /* Space between icon and text */
      padding: 8px 18px;
      background: rgba(255, 204, 112, 0.1);
      color: #ffcc70;
      text-decoration: none;
      font-weight: bold;
      border-radius: 20px;
      border: 1px solid #ffcc70;
      transition: background 0.3s, color 0.3s;
    }
    .project-link:hover {
      background: #ffcc70;
      color: #0d0d0d;
    }

    /* --- Contact Form --- */
    #contact-form {
      margin-top: 30px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    #contact-form input,
    #contact-form textarea {
      width: 100%;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: #e0e0e0;
      font-family: inherit;
      font-size: 1rem;
    }
    #contact-form input:focus,
    #contact-form textarea:focus {
      outline: none;
      border-color: #ffcc70;
      box-shadow: 0 0 10px rgba(255, 204, 112, 0.3);
    }
    #contact-form textarea {
      min-height: 150px;
      resize: vertical;
    }
    #contact-form button {
      padding: 14px 28px;
      border-radius: 50px;
      background: #ffcc70;
      border: 1px solid #ffcc70;
      color: #0d0d0d;
      font-weight: bold;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      align-self: flex-start; /* Align button to the left */
    }
    #contact-form button:hover {
      background: transparent;
      color: #ffcc70;
      transform: scale(1.05);
    }
    
    #form-status {
      margin-top: 20px;
      text-align: center;
      color: #9ece6a; /* Success color */
      font-weight: 500;
      min-height: 1.2em;
      transition: opacity 0.3s ease-in-out;
    }
    
    /* --- Footer --- */
    footer {
      text-align: center;
      padding: 30px;
      margin-top: 60px;
      background: rgba(0,0,0,0.8);
      position: relative;
      z-index: 1;
    }

    /* --- Responsive Adjustments --- */
    @media (max-width: 768px) {
        nav {
            padding: 15px 2%;
            justify-content: space-around; /* Better spacing on smaller screens */
        }
        nav a {
            margin: 0 10px;
        }
        .social-bar {
            flex-direction: row;
            top: auto;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            padding: 10px;
            background: rgba(13, 13, 13, 0.8);
            justify-content: center;
        }
        section {
            padding: 30px 25px;
            margin: 80px auto;
        }
        /* Stack about me section on mobile */
        .about-container {
            flex-direction: column;
            text-align: center;
        }
    }

  </style>
</head>
<body>

  <div id="vanta-bg"></div>

  <!-- Splash Cursor Canvas -->
  <div id="splash-cursor-container">
    <canvas id="fluid-canvas"></canvas>
  </div>


  <nav id="navbar">
    <a href="#about">About</a>
    <a href="#skills">Skills</a>
    <a href="#projects">Projects</a>
    <a href="#internship">Internship</a>
    <a href="#contact">Contact</a>
  </nav>

  <div class="social-bar">
    <a href="mailto:akashdoss996@gmail.com" title="Email">
      <img src="https://cdn-icons-png.flaticon.com/512/732/732200.png" alt="Email" style="background:white; border-radius:50%;">
    </a>
    <a href="https://github.com/akashdoss" target="_blank" title="GitHub">
      <img src="https://cdn-icons-png.flaticon.com/512/733/733553.png" alt="GitHub" style="background:white; border-radius:50%;">
    </a>
    <a href="https://www.linkedin.com/in/akash-selvadoss-n-542765252/" target="_blank" title="LinkedIn">
      <img src="https://cdn-icons-png.flaticon.com/512/3536/3536505.png" alt="LinkedIn">
    </a>
  </div>

  <header>
    <h1>Akash Selvadoss N</h1>
    <a href="#about" class="btn">Explore My Work</a>
  </header>
  
  <main>
    <section id="profile">
      <h2>Profile Info</h2>
      <p><strong>From:</strong> Tirunelveli, Tamil Nadu</p>
      <p><strong>B.Tech:</strong> Artificial Intelligence & Data Science (CGPA: 7.56) - National Engineering College</p>
      <p><strong>12th:</strong> SAV Balakrishna CBSE School – 69%</p>
      <p><strong>10th:</strong> SAV Balakrishna CBSE School – 71%</p>
    </section>

    <section id="about">
      <h2>About Me</h2>
      <div class="about-container">
        <div class="profile-picture-container">
          <img src="https://i.ibb.co/jPnyVbZs/Gemini-Generated-Image-fqtcpffqtcpffqtc.png" alt="Akash Selvadoss N - Profile Picture" class="profile-picture">
        </div>
        <div class="about-text">
          <p>
            I am Akash Selvadoss from Tirunelveli, a dedicated student of Artificial Intelligence and Data Science. My interest lies in applying AI and machine learning to solve real-world challenges. I am fascinated by how data can be transformed into meaningful insights and practical applications.
          </p>
          <p>
            Beyond academics, I enjoy building projects that blend creativity with technology. I am also an active content creator, running a YouTube channel with 2.4K+ subscribers, where I share coding tutorials, project demos, and insights about AI.
          </p>
        </div>
      </div>
    </section>

    <section id="skills">
      <h2>Skills</h2>
      <ul>
        <li>Programming: Java, Python, SQL</li>
        <li>AI/ML: Generative AI, Machine Learning Techniques</li>
        <li>Tools: Microsoft Office, GitHub, Render</li>
        <li>Soft Skills: Communication, Team Management, Adaptability</li>
      </ul>
    </section>

    <section id="projects">
      <h2>Projects</h2>
      <div class="project-grid">
        <div class="project-card">
          <strong>Medobot – Virtual Medical Assistant</strong>
          <p>
            Developed an AI chatbot capable of extracting medicine details from text, voice, or images, using Tesseract OCR, Gemini API, and Google Speech Recognition.
          </p>
          <div class="project-links-container">
            <a href="https://github.com/akashdoss/Medobot" target="_blank" class="project-link">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
              GitHub
            </a>
          </div>
        </div>
        <div class="project-card">
          <strong>Syntaxia 2.0 – Smart AI Coding Assistant</strong>
          <p>
            Developed a sleek web application powered by Google's Gemini API to help developers understand, debug, and improve code with AI-driven explanations and fixes.
          </p>
          <div class="project-links-container">
            <a href="https://syntaxa-20.vercel.app/" target="_blank" class="project-link">Live Demo</a>
            <a href="https://github.com/akashdoss/Syntaxa_2.0" target="_blank" class="project-link">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
              GitHub
            </a>
          </div>
        </div>
        <div class="project-card">
          <strong>GemTalk – AI Chat Interface</strong>
          <p>
            Developed a sleek, privacy-focused web application to interact with Google's Gemini models. Built with a Python-Flask backend and a dynamic frontend using vanilla HTML, CSS, and JavaScript.
          </p>
          <div class="project-links-container">
            <a href="https://gemtalk-theta.vercel.app/" target="_blank" class="project-link">Live Demo</a>
            <a href="https://github.com/akashdoss/GemTalk" target="_blank" class="project-link">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
              GitHub
            </a>
          </div>
        </div>
        <div class="project-card">
          <strong>Conversational AI & Visuals</strong>
          <p>
            Built an AI chatbot using SambaNova API integrated with a text-to-image generator (Hugging Face + Nebius). Designed to handle interactive queries and generate creative images dynamically.
          </p>
          <div class="project-links-container">
            <a href="https://github.com/akashdoss/AkashGPT" target="_blank" class="project-link">
              <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
              GitHub
            </a>
          </div>
        </div>
      </div>
    </section>

    <section id="internship">
      <h2>Internship</h2>
      <p>
        <strong>Software Intern – Shanmuga AI Technology (Nov - Mar 2025)</strong><br>
        Worked on backend development for scalable applications, optimized code performance, and collaborated with a cross-functional team using agile practices to deliver features that improved project efficiency.
      </p>
      <a href="https://i.ibb.co/HDm9qhnZ/Screenshot-2025-09-19-at-4-23-59-PM.png" target="_blank" class="project-link" style="margin-top: 15px;">View Certificate</a>
    </section>

    <section id="certifications">
      <h2>Certifications</h2>
      <ul>
        <li>Data Analytics & Visualization Job Simulation (Jun 2024)</li>
        <li>Machine Learning - Dimensionality Reduction (Jun 2024)</li>
        <li>Data Analysis with Python (Aug 2024)</li>
        <li>Database Management System (Springboard, May 2024)</li>
        <li>E-Business - NPTEL</li>
      </ul>
    </section>

    <section id="contact"> <!-- Combined Extra-curricular into a contact section -->
      <h2>Get In Touch / Find Me Online</h2>
      <p>
        I'm always open to discussing new projects, creative ideas, or opportunities to be part of an ambitious team. Feel free to reach out via email or connect with me on social media.
      </p>
      <p>
        You can also check out my YouTube Channel: <strong>Doss Explores</strong>, where I share coding tutorials and tech content with over 2.4K subscribers.  
        <a href="https://www.youtube.com/@dossexplores1" target="_blank" class="project-link" style="margin-top:10px;">Visit Channel</a>
      </p>
      <form id="contact-form">
        <input type="email" name="email" placeholder="Your Email" required>
        <textarea name="message" placeholder="Your Message" required></textarea>
        <button type="submit">Send Message</button>
      </form>
      <div id="form-status"></div>
    </section>
  </main>
  
  <footer>
    <p>&copy; 2025 Akash Selvadoss N | All Rights Reserved</p>
  </footer>

  <!-- Vanta.js Background Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vanta/0.5.24/vanta.globe.min.js"></script>
  <script>
    // Initialize Vanta.js Globe Background
    VANTA.GLOBE({
      el: "#vanta-bg", // Target the dedicated background div
      mouseControls: true,
      touchControls: true,
      gyroControls: false,
      minHeight: 200.00,
      minWidth: 200.00,
      scale: 1.00,
      scaleMobile: 1.00,
      backgroundColor: 0x0d0d0d, // Dark background to match theme
      color: 0xffcc70, // Accent color for the globe continents/lines
      color2: 0x32e0c4, // Secondary accent color
      size: 1.20 // Slightly increase globe size
    });
  </script>
  
  <!-- SCRIPT for Active Nav Link on Scroll -->
  <script>
    const sections = document.querySelectorAll('main section'); // Target sections inside main
    const navLinks = document.querySelectorAll('nav a');

    window.addEventListener('scroll', ()=> {
        let current = '';
        sections.forEach( section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.clientHeight;
            // A buffer of 150px so the link becomes active a bit sooner
            if(pageYOffset >= (sectionTop - 150)){
                current = section.getAttribute('id');
            }
        });

        navLinks.forEach( a => {
            a.classList.remove('active');
            // Check if the link's href matches the current section's id
            if(a.getAttribute('href').substring(1) === current){
                a.classList.add('active');
            }
        });
    });
  </script>

  <!-- SCRIPT for Contact Form Submission -->
  <script>
    document.getElementById('contact-form').addEventListener('submit', function(event) {
      event.preventDefault();
      const status = document.getElementById('form-status');
      status.textContent = 'Thank you! Akash Doss has been notified.';
      this.reset();
      setTimeout(() => {
        status.textContent = '';
      }, 5000);
    });
  </script>

  <!-- SCRIPT for Fluid Splash Cursor -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('fluid-canvas');
        if (!canvas) return;

        function pointerPrototype() {
            this.id = -1;
            this.texcoordX = 0;
            this.texcoordY = 0;
            this.prevTexcoordX = 0;
            this.prevTexcoordY = 0;
            this.deltaX = 0;
            this.deltaY = 0;
            this.down = false;
            this.moved = false;
            this.color = [0, 0, 0];
        }

        let config = {
            SIM_RESOLUTION: 128,
            DYE_RESOLUTION: 1440,
            CAPTURE_RESOLUTION: 512,
            DENSITY_DISSIPATION: 3.5,
            VELOCITY_DISSIPATION: 2,
            PRESSURE: 0.1,
            PRESSURE_ITERATIONS: 20,
            CURL: 3,
            SPLAT_RADIUS: 0.2,
            SPLAT_FORCE: 6000,
            SHADING: true,
            COLOR_UPDATE_SPEED: 10,
            PAUSED: false,
            BACK_COLOR: { r: 0.5, g: 0, b: 0 },
            TRANSPARENT: true
        };

        let pointers = [new pointerPrototype()];

        const { gl, ext } = getWebGLContext(canvas);
        if (ext && !ext.supportLinearFiltering) {
            config.DYE_RESOLUTION = 256;
            config.SHADING = false;
        }

        function getWebGLContext(canvas) {
            const params = {
                alpha: true,
                depth: false,
                stencil: false,
                antialias: false,
                preserveDrawingBuffer: false
            };
            let gl = canvas.getContext('webgl2', params);
            const isWebGL2 = !!gl;
            if (!isWebGL2) gl = canvas.getContext('webgl', params) || canvas.getContext('experimental-webgl', params);
            if (!gl) return {};

            let halfFloat;
            let supportLinearFiltering;
            if (isWebGL2) {
                gl.getExtension('EXT_color_buffer_float');
                supportLinearFiltering = gl.getExtension('OES_texture_float_linear');
            } else {
                halfFloat = gl.getExtension('OES_texture_half_float');
                supportLinearFiltering = gl.getExtension('OES_texture_half_float_linear');
            }
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            const halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat && halfFloat.HALF_FLOAT_OES;
            let formatRGBA;
            let formatRG;
            let formatR;

            if (isWebGL2) {
                formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
                formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
                formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
            } else {
                formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
            }

            return {
                gl,
                ext: {
                    formatRGBA,
                    formatRG,
                    formatR,
                    halfFloatTexType,
                    supportLinearFiltering
                }
            };
        }

        function getSupportedFormat(gl, internalFormat, format, type) {
            if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
                switch (internalFormat) {
                    case gl.R16F:
                        return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
                    case gl.RG16F:
                        return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
                    default:
                        return null;
                }
            }
            return { internalFormat, format };
        }

        function supportRenderTextureFormat(gl, internalFormat, format, type) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);
            const fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            return status === gl.FRAMEBUFFER_COMPLETE;
        }

        class Material {
            constructor(vertexShader, fragmentShaderSource) {
                this.vertexShader = vertexShader;
                this.fragmentShaderSource = fragmentShaderSource;
                this.programs = [];
                this.activeProgram = null;
                this.uniforms = [];
            }
            setKeywords(keywords) {
                let hash = 0;
                for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);
                let program = this.programs[hash];
                if (program == null) {
                    let fragmentShader = compileShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource, keywords);
                    program = createProgram(this.vertexShader, fragmentShader);
                    this.programs[hash] = program;
                }
                if (program === this.activeProgram) return;
                this.uniforms = getUniforms(program);
                this.activeProgram = program;
            }
            bind() {
                gl.useProgram(this.activeProgram);
            }
        }

        class Program {
            constructor(vertexShader, fragmentShader) {
                this.uniforms = {};
                this.program = createProgram(vertexShader, fragmentShader);
                this.uniforms = getUniforms(this.program);
            }
            bind() {
                gl.useProgram(this.program);
            }
        }

        function createProgram(vertexShader, fragmentShader) {
            let program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) console.trace(gl.getProgramInfoLog(program));
            return program;
        }

        function getUniforms(program) {
            let uniforms = [];
            let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
            for (let i = 0; i < uniformCount; i++) {
                let uniformName = gl.getActiveUniform(program, i).name;
                uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
            }
            return uniforms;
        }

        function compileShader(type, source, keywords) {
            source = addKeywords(source, keywords);
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.trace(gl.getShaderInfoLog(shader));
            return shader;
        }

        function addKeywords(source, keywords) {
            if (!keywords) return source;
            let keywordsString = '';
            keywords.forEach(keyword => {
                keywordsString += '#define ' + keyword + '\n';
            });
            return keywordsString + source;
        }

        const baseVertexShader = compileShader(gl.VERTEX_SHADER, `
            precision highp float;
            attribute vec2 aPosition;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform vec2 texelSize;

            void main () {
                vUv = aPosition * 0.5 + 0.5;
                vL = vUv - vec2(texelSize.x, 0.0);
                vR = vUv + vec2(texelSize.x, 0.0);
                vT = vUv + vec2(0.0, texelSize.y);
                vB = vUv - vec2(0.0, texelSize.y);
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `);

        const copyShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            precision mediump sampler2D;
            varying highp vec2 vUv;
            uniform sampler2D uTexture;
            void main () { gl_FragColor = texture2D(uTexture, vUv); }
        `);

        const clearShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            varying highp vec2 vUv;
            uniform sampler2D uTexture;
            uniform float value;
            void main () { gl_FragColor = value * texture2D(uTexture, vUv); }
        `);

        const displayShaderSource = `
            precision highp float;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uTexture;
            uniform vec2 texelSize;

            void main () {
                vec3 c = texture2D(uTexture, vUv).rgb;
                #ifdef SHADING
                    vec3 lc = texture2D(uTexture, vL).rgb;
                    vec3 rc = texture2D(uTexture, vR).rgb;
                    vec3 tc = texture2D(uTexture, vT).rgb;
                    vec3 bc = texture2D(uTexture, vB).rgb;
                    float dx = length(rc) - length(lc);
                    float dy = length(tc) - length(bc);
                    vec3 n = normalize(vec3(dx, dy, length(texelSize)));
                    vec3 l = vec3(0.0, 0.0, 1.0);
                    float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
                    c *= diffuse;
                #endif
                float a = max(c.r, max(c.g, c.b));
                gl_FragColor = vec4(c, a);
            }
        `;

        const splatShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec3 color;
            uniform vec2 point;
            uniform float radius;
            void main () {
                vec2 p = vUv - point.xy;
                p.x *= aspectRatio;
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `);

        const advectionShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            varying vec2 vUv;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform vec2 dyeTexelSize;
            uniform float dt;
            uniform float dissipation;
            vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
                vec2 st = uv / tsize - 0.5;
                vec2 iuv = floor(st);
                vec2 fuv = fract(st);
                vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
                vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
                vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
                vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);
                return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
            }
            void main () {
                #ifdef MANUAL_FILTERING
                    vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
                    vec4 result = bilerp(uSource, coord, dyeTexelSize);
                #else
                    vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                    vec4 result = texture2D(uSource, coord);
                #endif
                float decay = 1.0 + dissipation * dt;
                gl_FragColor = result / decay;
            }
        `, ext.supportLinearFiltering ? null : ['MANUAL_FILTERING']);

        const divergenceShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            varying highp vec2 vUv, vL, vR, vT, vB;
            uniform sampler2D uVelocity;
            void main () {
                float L = texture2D(uVelocity, vL).x;
                float R = texture2D(uVelocity, vR).x;
                float T = texture2D(uVelocity, vT).y;
                float B = texture2D(uVelocity, vB).y;
                vec2 C = texture2D(uVelocity, vUv).xy;
                if (vL.x < 0.0) { L = -C.x; }
                if (vR.x > 1.0) { R = -C.x; }
                if (vT.y > 1.0) { T = -C.y; }
                if (vB.y < 0.0) { B = -C.y; }
                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `);

        const curlShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            varying highp vec2 vUv, vL, vR, vT, vB;
            uniform sampler2D uVelocity;
            void main () {
                float L = texture2D(uVelocity, vL).y;
                float R = texture2D(uVelocity, vR).y;
                float T = texture2D(uVelocity, vT).x;
                float B = texture2D(uVelocity, vB).x;
                float vorticity = R - L - T + B;
                gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
            }
        `);

        const vorticityShader = compileShader(gl.FRAGMENT_SHADER, `
            precision highp float;
            varying vec2 vUv, vL, vR, vT, vB;
            uniform sampler2D uVelocity, uCurl;
            uniform float curl, dt;
            void main () {
                float L = texture2D(uCurl, vL).x;
                float R = texture2D(uCurl, vR).x;
                float T = texture2D(uCurl, vT).x;
                float B = texture2D(uCurl, vB).x;
                float C = texture2D(uCurl, vUv).x;
                vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
                force /= length(force) + 0.0001;
                force *= curl * C;
                force.y *= -1.0;
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity += force * dt;
                velocity = min(max(velocity, -1000.0), 1000.0);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `);

        const pressureShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            varying highp vec2 vUv, vL, vR, vT, vB;
            uniform sampler2D uPressure, uDivergence;
            void main () {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                float divergence = texture2D(uDivergence, vUv).x;
                float pressure = (L + R + B + T - divergence) * 0.25;
                gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
            }
        `);

        const gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, `
            precision mediump float;
            varying highp vec2 vUv, vL, vR, vT, vB;
            uniform sampler2D uPressure, uVelocity;
            void main () {
                float L = texture2D(uPressure, vL).x;
                float R = texture2D(uPressure, vR).x;
                float T = texture2D(uPressure, vT).x;
                float B = texture2D(uPressure, vB).x;
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity.xy -= vec2(R - L, T - B);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `);

        const blit = (() => {
            gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);
            return (target, clear = false) => {
                if (target == null) {
                    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                } else {
                    gl.viewport(0, 0, target.width, target.height);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
                }
                if (clear) {
                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                }
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            };
        })();

        let dye, velocity, divergence, curl, pressure;
        const copyProgram = new Program(baseVertexShader, copyShader);
        const clearProgram = new Program(baseVertexShader, clearShader);
        const splatProgram = new Program(baseVertexShader, splatShader);
        const advectionProgram = new Program(baseVertexShader, advectionShader);
        const divergenceProgram = new Program(baseVertexShader, divergenceShader);
        const curlProgram = new Program(baseVertexShader, curlShader);
        const vorticityProgram = new Program(baseVertexShader, vorticityShader);
        const pressureProgram = new Program(baseVertexShader, pressureShader);
        const gradienSubtractProgram = new Program(baseVertexShader, gradientSubtractShader);
        const displayMaterial = new Material(baseVertexShader, displayShaderSource);

        function initFramebuffers() {
            let simRes = getResolution(config.SIM_RESOLUTION);
            let dyeRes = getResolution(config.DYE_RESOLUTION);
            const texType = ext.halfFloatTexType;
            const rgba = ext.formatRGBA;
            const rg = ext.formatRG;
            const r = ext.formatR;
            const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
            gl.disable(gl.BLEND);

            if (!dye) dye = createDoubleFBO(dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);
            else dye = resizeDoubleFBO(dye, dyeRes.width, dyeRes.height, rgba.internalFormat, rgba.format, texType, filtering);

            if (!velocity) velocity = createDoubleFBO(simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);
            else velocity = resizeDoubleFBO(velocity, simRes.width, simRes.height, rg.internalFormat, rg.format, texType, filtering);

            divergence = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
            curl = createFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
            pressure = createDoubleFBO(simRes.width, simRes.height, r.internalFormat, r.format, texType, gl.NEAREST);
        }

        function createFBO(w, h, internalFormat, format, type, param) {
            gl.activeTexture(gl.TEXTURE0);
            let texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
            let fbo = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.viewport(0, 0, w, h);
            gl.clear(gl.COLOR_BUFFER_BIT);
            return {
                texture,
                fbo,
                width: w,
                height: h,
                texelSizeX: 1.0 / w,
                texelSizeY: 1.0 / h,
                attach(id) {
                    gl.activeTexture(gl.TEXTURE0 + id);
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    return id;
                }
            };
        }

        function createDoubleFBO(w, h, internalFormat, format, type, param) {
            let fbo1 = createFBO(w, h, internalFormat, format, type, param);
            let fbo2 = createFBO(w, h, internalFormat, format, type, param);
            return {
                width: w,
                height: h,
                texelSizeX: fbo1.texelSizeX,
                texelSizeY: fbo1.texelSizeY,
                get read() { return fbo1; },
                set read(value) { fbo1 = value; },
                get write() { return fbo2; },
                set write(value) { fbo2 = value; },
                swap() { let temp = fbo1; fbo1 = fbo2; fbo2 = temp; }
            };
        }

        function resizeFBO(target, w, h, internalFormat, format, type, param) {
            let newFBO = createFBO(w, h, internalFormat, format, type, param);
            copyProgram.bind();
            gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
            blit(newFBO);
            return newFBO;
        }

        function resizeDoubleFBO(target, w, h, internalFormat, format, type, param) {
            if (target.width === w && target.height === h) return target;
            target.read = resizeFBO(target.read, w, h, internalFormat, format, type, param);
            target.write = createFBO(w, h, internalFormat, format, type, param);
            target.width = w;
            target.height = h;
            target.texelSizeX = 1.0 / w;
            target.texelSizeY = 1.0 / h;
            return target;
        }

        function updateKeywords() {
            let displayKeywords = [];
            if (config.SHADING) displayKeywords.push('SHADING');
            displayMaterial.setKeywords(displayKeywords);
        }

        updateKeywords();
        initFramebuffers();
        let lastUpdateTime = Date.now();
        let colorUpdateTimer = 0.0;
        let animationFrameRequest;

        function updateFrame() {
            const dt = calcDeltaTime();
            if (resizeCanvas()) initFramebuffers();
            updateColors(dt);
            applyInputs();
            step(dt);
            render(null);
            animationFrameRequest = requestAnimationFrame(updateFrame);
        }

        function calcDeltaTime() {
            let now = Date.now();
            let dt = (now - lastUpdateTime) / 1000;
            dt = Math.min(dt, 0.016666);
            lastUpdateTime = now;
            return dt;
        }

        function resizeCanvas() {
            let width = scaleByPixelRatio(canvas.clientWidth);
            let height = scaleByPixelRatio(canvas.clientHeight);
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                return true;
            }
            return false;
        }

        function updateColors(dt) {
            colorUpdateTimer += dt * config.COLOR_UPDATE_SPEED;
            if (colorUpdateTimer >= 1) {
                colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);
                pointers.forEach(p => { p.color = generateColor(); });
            }
        }

        function applyInputs() {
            pointers.forEach(p => {
                if (p.moved) {
                    p.moved = false;
                    splatPointer(p);
                }
            });
        }

        function step(dt) {
            gl.disable(gl.BLEND);
            curlProgram.bind();
            gl.uniform2f(curlProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
            blit(curl);

            vorticityProgram.bind();
            gl.uniform2f(vorticityProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
            gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
            gl.uniform1f(vorticityProgram.uniforms.dt, dt);
            blit(velocity.write);
            velocity.swap();

            divergenceProgram.bind();
            gl.uniform2f(divergenceProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0));
            blit(divergence);

            clearProgram.bind();
            gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
            gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE);
            blit(pressure.write);
            pressure.swap();

            pressureProgram.bind();
            gl.uniform2f(pressureProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
            for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1));
                blit(pressure.write);
                pressure.swap();
            }

            gradienSubtractProgram.bind();
            gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0));
            gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1));
            blit(velocity.write);
            velocity.swap();

            advectionProgram.bind();
            gl.uniform2f(advectionProgram.uniforms.texelSize, velocity.texelSizeX, velocity.texelSizeY);
            if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, velocity.texelSizeX, velocity.texelSizeY);
            let velocityId = velocity.read.attach(0);
            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);
            gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);
            gl.uniform1f(advectionProgram.uniforms.dt, dt);
            gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION);
            blit(velocity.write);
            velocity.swap();

            if (!ext.supportLinearFiltering) gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, dye.texelSizeX, dye.texelSizeY);
            gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0));
            gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
            gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION);
            blit(dye.write);
            dye.swap();
        }

        function render(target) {
            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.enable(gl.BLEND);
            drawDisplay(target);
        }

        function drawDisplay(target) {
            let width = target == null ? gl.drawingBufferWidth : target.width;
            let height = target == null ? gl.drawingBufferHeight : target.height;
            displayMaterial.bind();
            if (config.SHADING) gl.uniform2f(displayMaterial.uniforms.texelSize, 1.0 / width, 1.0 / height);
            gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
            blit(target);
        }

        function splatPointer(pointer) {
            let dx = pointer.deltaX * config.SPLAT_FORCE;
            let dy = pointer.deltaY * config.SPLAT_FORCE;
            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);
        }

        function clickSplat(pointer) {
            const color = generateColor();
            color.r *= 10.0;
            color.g *= 10.0;
            color.b *= 10.0;
            let dx = 10 * (Math.random() - 0.5);
            let dy = 30 * (Math.random() - 0.5);
            splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);
        }

        function splat(x, y, dx, dy, color) {
            splatProgram.bind();
            gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
            gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height);
            gl.uniform2f(splatProgram.uniforms.point, x, y);
            gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);
            gl.uniform1f(splatProgram.uniforms.radius, correctRadius(config.SPLAT_RADIUS / 100.0));
            blit(velocity.write);
            velocity.swap();

            gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
            gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
            blit(dye.write);
            dye.swap();
        }

        function correctRadius(radius) {
            let aspectRatio = canvas.width / canvas.height;
            if (aspectRatio > 1) radius *= aspectRatio;
            return radius;
        }

        function updatePointerDownData(pointer, id, posX, posY) {
            pointer.id = id;
            pointer.down = true;
            pointer.moved = false;
            pointer.texcoordX = posX / canvas.width;
            pointer.texcoordY = 1.0 - posY / canvas.height;
            pointer.prevTexcoordX = pointer.texcoordX;
            pointer.prevTexcoordY = pointer.texcoordY;
            pointer.deltaX = 0;
            pointer.deltaY = 0;
            pointer.color = generateColor();
        }

        function updatePointerMoveData(pointer, posX, posY, color) {
            pointer.prevTexcoordX = pointer.texcoordX;
            pointer.prevTexcoordY = pointer.texcoordY;
            pointer.texcoordX = posX / canvas.width;
            pointer.texcoordY = 1.0 - posY / canvas.height;
            pointer.deltaX = correctDeltaX(pointer.texcoordX - pointer.prevTexcoordX);
            pointer.deltaY = correctDeltaY(pointer.texcoordY - pointer.prevTexcoordY);
            pointer.moved = Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;
            pointer.color = color;
        }

        function updatePointerUpData(pointer) {
            pointer.down = false;
        }

        function correctDeltaX(delta) {
            let aspectRatio = canvas.width / canvas.height;
            if (aspectRatio < 1) delta *= aspectRatio;
            return delta;
        }

        function correctDeltaY(delta) {
            let aspectRatio = canvas.width / canvas.height;
            if (aspectRatio > 1) delta /= aspectRatio;
            return delta;
        }

        function generateColor() {
            let c = HSVtoRGB(Math.random(), 1.0, 1.0);
            c.r *= 0.15;
            c.g *= 0.15;
            c.b *= 0.15;
            return c;
        }

        function HSVtoRGB(h, s, v) {
            let r, g, b, i, f, p, q, t;
            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v; g = t; b = p; break;
                case 1: r = q; g = v; b = p; break;
                case 2: r = p; g = v; b = t; break;
                case 3: r = p; g = q; b = v; break;
                case 4: r = t; g = p; b = v; break;
                case 5: r = v; g = p; b = q; break;
            }
            return { r, g, b };
        }

        function wrap(value, min, max) {
            const range = max - min;
            if (range === 0) return min;
            return ((value - min) % range) + min;
        }

        function getResolution(resolution) {
            let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
            if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;
            const min = Math.round(resolution);
            const max = Math.round(resolution * aspectRatio);
            return (gl.drawingBufferWidth > gl.drawingBufferHeight) ? { width: max, height: min } : { width: min, height: max };
        }

        function scaleByPixelRatio(input) {
            const pixelRatio = window.devicePixelRatio || 1;
            return Math.floor(input * pixelRatio);
        }

        function hashCode(s) {
            if (s.length === 0) return 0;
            let hash = 0;
            for (let i = 0; i < s.length; i++) {
                hash = (hash << 5) - hash + s.charCodeAt(i);
                hash |= 0;
            }
            return hash;
        }
        
        let hasAnimationStarted = false;

        function startAnimation() {
            if (hasAnimationStarted) return;
            hasAnimationStarted = true;
            updateFrame();
        }

        window.addEventListener('mousedown', e => {
            let pointer = pointers[0];
            let posX = scaleByPixelRatio(e.clientX);
            let posY = scaleByPixelRatio(e.clientY);
            updatePointerDownData(pointer, -1, posX, posY);
            clickSplat(pointer);
        });

        document.body.addEventListener('mousemove', function handleFirstMouseMove(e) {
            let pointer = pointers[0];
            let posX = scaleByPixelRatio(e.clientX);
            let posY = scaleByPixelRatio(e.clientY);
            let color = generateColor();
            startAnimation();
            updatePointerMoveData(pointer, posX, posY, color);
        }, { once: true });

        window.addEventListener('mousemove', e => {
            let pointer = pointers[0];
            let posX = scaleByPixelRatio(e.clientX);
            let posY = scaleByPixelRatio(e.clientY);
            let color = pointer.color;
            updatePointerMoveData(pointer, posX, posY, color);
        });

        document.body.addEventListener('touchstart', function handleFirstTouchStart(e) {
            const touches = e.targetTouches;
            let pointer = pointers[0];
            for (let i = 0; i < touches.length; i++) {
                let posX = scaleByPixelRatio(touches[i].clientX);
                let posY = scaleByPixelRatio(touches[i].clientY);
                startAnimation();
                updatePointerDownData(pointer, touches[i].identifier, posX, posY);
            }
        }, { once: true });

        window.addEventListener('touchstart', e => {
            const touches = e.targetTouches;
            let pointer = pointers[0];
            for (let i = 0; i < touches.length; i++) {
                let posX = scaleByPixelRatio(touches[i].clientX);
                let posY = scaleByPixelRatio(touches[i].clientY);
                updatePointerDownData(pointer, touches[i].identifier, posX, posY);
            }
        });

        window.addEventListener('touchmove', e => {
            const touches = e.targetTouches;
            let pointer = pointers[0];
            for (let i = 0; i < touches.length; i++) {
                let posX = scaleByPixelRatio(touches[i].clientX);
                let posY = scaleByPixelRatio(touches[i].clientY);
                updatePointerMoveData(pointer, posX, posY, pointer.color);
            }
        }, false);

        window.addEventListener('touchend', e => {
            const touches = e.changedTouches;
            let pointer = pointers[0];
            for (let i = 0; i < touches.length; i++) {
                updatePointerUpData(pointer);
            }
        });
    });
  </script>

</body>
</html>
